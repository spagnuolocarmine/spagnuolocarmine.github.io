---
layout: posts
title: Programmazione concorrente, parallela e su cloud - Class 2019/20
category: teaching
---


<h2> Master Degree Course of prof. Vittorio Scarano and Carmine Spagnuolo, Ph.D., Università degli Studi di Salerno</h2>

## Table of contents
- [Books and references](#books-and-references)
- [Materials for online course](#materials-for-online-course)
  - [Lessons](#lessons)
  - [Have fun with MPI in C](#have-fun-with-mpi-in-c)
  - [Class question forum](#class-question-forum)
- [Course homeworks](#course-homeworks)
  - [Which is my homework?](#which-is-my-homework)
  - [Homeworks list](#homeworks-list)
    - [Game of Life](#game-of-life)
    - [N-Body](#n-body)
    - [Word Count](#word-count)
  - [Give me a project now!](#give-me-a-project-now)
- [Submit your course homework](#submit-your-course-homework)
  - [Prepare your submission](#prepare-your-submission)
    - [Submission instructions](#submission-instructions)
- [Homework evaluation criteria](#homework-evaluation-criteria)
  - [How to have a successful homework evaluation?](#how-to-have-a-successful-homework-evaluation)
  - [Benchmarks TIPS](#benchmarks-tips)
  - [How benchmark your MPI program on a AWS EC2 cluster?](#how-benchmark-your-mpi-program-on-a-aws-ec2-cluster)
- [The last "dance" of your course](#the-last-%22dance%22-of-your-course)

# Books and references

1. Kai Hwang, Jack Dongarra, and Geoffrey C. Fox. 2011. Distributed and Cloud Computing: From Parallel Processing to the Internet of Things (1st ed.). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA.
2. Czech, Z. (2017). Introduction to Parallel Computing. Cambridge: Cambridge University Press.
3. 📖 [Have fun with MPI in C](http://bit.ly/have-fun-with-mpi-in-c)

# Materials for online course

## Lessons
- 📅 02/03/2020
    - 🔗 [AWS Overview](https://spagnuolocarmine.github.io/assets/files/pcpc2020/aws-overview.pdf)
    - 🔖 [Slides A](https://spagnuolocarmine.github.io/assets/files/pcpc2020/02032020_a.pdf)
    - 🔖 [Slides B](https://spagnuolocarmine.github.io/assets/files/pcpc2020/02032020_b.pdf)
- 📅 16/03/2020
    - 🔖 [Slides](https://spagnuolocarmine.github.io/assets/files/pcpc2020/16032020.pdf)
    - 🔗 [![Public class chat https://gitter.im/isislab-unisa/pcpc2020](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/isislab-unisa/pcpc2020?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) <span style="color:red">**(dismissed)**
    -  🔗 [![Discord](https://img.shields.io/discord/693092516286693387.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/BTt5fUp) ISISLab Community
       -  Channel **#pcpc**
    - 🛠 [Install OpenMPI on Linux Ubuntu](https://github.com/spagnuolocarmine/ubuntu-openmpi-openmp)
- 📅 20/03/2020
    - ⚙️ [Counting sort](https://spagnuolocarmine.github.io/news/counting-sort/)
    - 🔖 [Slides A](https://spagnuolocarmine.github.io/assets/files/pcpc2020/20032020_a.pdf)
    - 🔖 [Slides B](https://spagnuolocarmine.github.io/assets/files/pcpc2020/20032020_b.pdf)
- 📅 23/03/2020
    - 🔖 [Slides](https://spagnuolocarmine.github.io/assets/files/pcpc2020/23032020.pdf)
    - 🐳 [Docker Ubuntu OpenMPI](https://hub.docker.com/r/spagnuolocarmine/docker-mpi)
    - 🆘 [Usage Docker environment](https://tech.io/playgrounds/47058/have-fun-with-mpi-in-c/docker-mpi-environment)
- 📅 27/03/2020
    - 🔖 [Slides](https://spagnuolocarmine.github.io/assets/files/pcpc2020/27032020.pdf)
    - 📖 [Have fun with MPI in C](http://bit.ly/have-fun-with-mpi-in-c)
        - 📌 Chapter 1 - [Introduction](https://tech.io/playgrounds/47058/have-fun-with-mpi-in-c/lets-start-to-have-fun-with-mpi)
    - 🔗 [MPI 3.1 Official Documentation](https://spagnuolocarmine.github.io/assets/files/pcpc2020/mpi31-report.pdf)
    - 🧮 [Hello World](https://spagnuolocarmine.github.io/assets/files/pcpc2020/hello_world.c) source code.
    - 🧮 [Hello World, Have fun with MPI in C](https://spagnuolocarmine.github.io/assets/files/pcpc2020/hello_world_have_fun_with_mpi.c) source code.
- 📅 30/03/2020
    - 🔖 [Slides](https://spagnuolocarmine.github.io/assets/files/pcpc2020/30032020.pdf)
    - 📖 [Have fun with MPI in C](http://bit.ly/have-fun-with-mpi-in-c)
        - 📌 Chapter 2.1 - [MPI Memory Model](https://tech.io/playgrounds/47058/have-fun-with-mpi-in-c/mpi-memory-model)
        - 📌 Chapter 2.2 - [Blocking Communication](https://tech.io/playgrounds/47058/have-fun-with-mpi-in-c/blocking-communication)
    - 📓 [Homework 1](https://spagnuolocarmine.github.io/assets/files/pcpc2020/e30032020.pdf)
- 📅 03/04/2020
    - 🔖 [Slides](https://spagnuolocarmine.github.io/assets/files/pcpc2020/03042020.pdf)
    - 📖 [Have fun with MPI in C](http://bit.ly/have-fun-with-mpi-in-c)
        - 📌 Chapter 2.3 - [Communication Modes](https://tech.io/playgrounds/47058/have-fun-with-mpi-in-c/communication-modes)
        - 📌 Chapter 2.4 - [Non-Blocking Communication](https://tech.io/playgrounds/47058/have-fun-with-mpi-in-c/non-blocking-communication)
     - 📓 [Homework 2](https://spagnuolocarmine.github.io/assets/files/pcpc2020/e03042020.pdf)
- 📅 06/04/2020
    - 📓 [Homework 3](https://spagnuolocarmine.github.io/assets/files/pcpc2020/e06042020.pdf)
- 📅 17/04/2020
    - 🔖 [Slides](https://spagnuolocarmine.github.io/assets/files/pcpc2020/17042020.pdf)
    - 📖 [Have fun with MPI in C](http://bit.ly/have-fun-with-mpi-in-c)
        - 📌 Chapter 4 - [Collective Communication](https://tech.io/playgrounds/47058/have-fun-with-mpi-in-c/collective-communications-overview)
     - 📓 [Homework 4](https://spagnuolocarmine.github.io/assets/files/pcpc2020/e17042020.pdf)
- 📅 20/04/2020
    - 📖 [Have fun with MPI in C](http://bit.ly/have-fun-with-mpi-in-c)
        - 📌 Chapter 3 - [Communicate Noncontiguous Data](https://tech.io/playgrounds/29504739e1d9dae30ea1abacc9889fc385074/have-fun-with-mpi-in-c/communicate-noncontiguous-data)
     - 📓 [Homework 5](https://spagnuolocarmine.github.io/assets/files/pcpc2020/e20042020.pdf)
 - 📅 24/04/2020  
   - 👩🏻‍💻👨🏻‍💻 Discussion on exercises.
   - 💥 [Course Homework](#course-homeworks) presentation. 

[↑ Back to Index ↑](#table-of-contents)

## Have fun with MPI in C
```c 
#include <stdio.h>
#include <mpi.h>
#include <string.h>
static const char NERD[5] =  {0xF0, 0x9F, 0xA4, 0x93, '\0'};
static const char WORLD[5] =  {0xF0, 0x9F, 0x8C, 0x8D, '\0'};
static const char SLEEP[5] =  {	0xF0, 0x9F, 0x98, 0xB4, '\0'};
#define 🤓 {MPI_Init(NULL, NULL);  int world_rank; MPI_Comm_rank(MPI_COMM_WORLD, &world_rank); printf("I am the %s with rank %d ",NERD, world_rank);}
#define 🌍 ({int s; MPI_Comm_size(MPI_COMM_WORLD, &s); printf("of MPI %s of size %d ", WORLD, s);});
#define 😴 {printf("Goodbye %s\n",SLEEP);MPI_Finalize();return 0;}
#define P(x) printf(x)
#define I P("\a");
#define am P("\a");
#define the P("\a");
#define with P("\a");
#define rank P("\a");
#define size P("\a");
#define 🤔 {P("\a");};
#define of P("\a");
#define MPI P("\a");
#define Goodbye P("\a");
int main()
{  
	I am the 🤓 with rank 🤔 of MPI 🌍 of size 🤔 Goodbye 😴;
}
```


## Class question forum

- [![Discord](https://img.shields.io/discord/693092516286693387.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/BTt5fUp) ISISLab Community
       -  Channel **#pcpc**
- Moreover, we use issues on [GitHub](https://github.com/spagnuolocarmine/spagnuolocarmine.github.io/issues). Please use it for sharing ideas and issues on both theoretical and practical course part.

-------------------------------------------------------------------------------------------------

# Course homeworks

## Which is my homework?


<p align="left">
<img src="https://www.open-mpi.org/images/open-mpi-logo.png" width="50px"/>
Each student must develop a solution for the assigned homework using parallel programming approach, and by exploiting distributed memory. The solution must be written in the C programming language, exploiting the OpenMPI library. Furthermore, the developed solution must be experimented on a homogeneous cluster running on top of the Amazon Web Services cloud computing platform. 
</p>

The cluster is composed of several supported [AWS Educate Instances](https://s3.amazonaws.com/awseducate-starter-account-services/AWS_Educate_Starter_Accounts_and_AWS_Services.pdf). The obtained results must be presented in terms of [strong and weak scalability](https://www.sharcnet.ca/help/index.php/Measuring_Parallel_Scaling_Performance), varying the number of computing processors from _1_ to _number-of-vcp_ _x_ _number-of-instances_. For example, if we run a cluster machine of _4_ t2.large (2 VCPU) nodes, we have to perform the scalability of our solution for P={1,2,4,5,6,7,8}.
 
 
The total number of processors is equal to the number of Virtual CPU on the running instances. The benchmark must exploit **8** instances for the more big experiment. The student must describe the solution and the benchmark in a report file, written in Markdown, and included in the submission in both the format Markdown and PDF. The report file must also describe the compilation phase and how to reproduce the results obtained, considering the Docker MPI environment of the course.

## Homeworks list 

ID | Name | Description 
------- | ------- | ------- 
1 | [_gameoflife_](#game-of-life) | [↓ Conway's Game of Life Game ↓](#game-of-life)
2 | [_nbody_](#n-body) | [↓ N-body problem ↓](#n-body) 
3 | [_wordcount_ ](#word-count)| [↓ Word Count↓](#word-count)

- A correct solution must generate the same results independently by the number of processors used. 
- Moreover, the program should provide simple functionalities for testing the results, allowing us to quickly compare the results of the execution using one processor and  P processors. 
- Finally, it is vital for keeping your solution <u>clear, concise, and easily understandable</u> by providing good code quality and fully describing it in the attached document.

### Game of Life
<details><summary>Open description ↓</summary>
<p>

<strong>Problem Description</strong>

The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.
The "game" is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. One interacts with the Game of Life by creating an initial configuration and observing how it evolves, or, for advanced "players," by creating patterns with particular properties.

<img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="nbody" width="200" style="margin: 10px auto 20px; display: block;" />


The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, alive or dead, or "populated" or "unpopulated." We can suppose to use a matrix of char, which marks if the cell is alive or dead.

Every cell interacts with its eight neighbors, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:
<br>
<ul>

<li> Any live cell with fewer than <strong>2</strong> live neighbors dies as if caused by underpopulation.</li> 
<li> Any live cell with <strong>2</strong> or <strong>3</strong> live neighbors lives on to the next generation.</li>
<li> Any live cell with more than <strong>3</strong> live neighbors dies, as if by overpopulation.</li>
<li> Any dead cell with exactly <strong>3</strong> live neighbors becomes a live cell, as if by reproduction.</li>

</ul>

<br>

The initial pattern constitutes the seed of the system. The first generation is created by applying the above rules simultaneously to every cell in the seed—births and deaths occur simultaneously, and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the preceding one). The rules continue to be applied repeatedly to create further generations.

<strong>Notes</strong>

The program must be able to simulate the process for a particular number of steps I. The MASTER process initializes a char matrix at random and split among P-1 processors. Notice that the MASTER can contribute to the computation or not; it is your choice. Each slave simulates the game and sends the corresponding ghost cells to its neighbor's processors, need in for the next simulation step. The hard part of the problem concerns equally divide the matrix among processors, which can be done in different ways. The most articulated solution divides the matrix in sub-matrix, and each processor sends to 8 neighbors:
<br>
<br>
CORNER - TOP - CORNER <br>
LEFT -  i - RIGHT <br>
CORNER - BOTTOM - CORNER <br>

</p>
</details>



### N-Body

<details><summary>Open description ↓</summary>
<p>

<strong>Problem Description</strong>

In the N-body problem, we need to find the positions and velocities of a collection of interacting particles over some time. For example, an astrophysicist might want to know the positions and velocities of a group of stars. In contrast, a chemist might want to know the positions and velocities of a collection of molecules or atoms.

<img src="https://mir-s3-cdn-cf.behance.net/project_modules/disp/b15a1122638879.56315fcc653b5.gif" alt="nbody" width="200" style="margin: 10px auto 20px; display: block;" />


An n-body solver is a program that finds the solution to an n-body problem by simulating the behavior of the particles. The input to the problem is the mass, position, and velocity of each particle at the start of the simulation, and the output is typically the position and velocity of each particle at a sequence of user-specified times, or merely the position and velocity of each particle at the end of a user-specified time.

Problem details are also available <a href="https://en.wikipedia.org/wiki/N-body_simulation".

<strong>Notes</strong>

Consider only the solution that is quadratic in the number of particles; however, also the Barnes-Hut algorithm can be considered but should be harder to develop. For the mathematical part (bodies force computation) of the problem, follow the guidelines of this solution: [example solution sequential](https://github.com/harrism/mini-nbody/blob/master/nbody.c).

The program must be able to simulate the process for a particular number of steps I. The MASTER process initializes an array of bodies at random and sends it to P-1 processors. Notice that the MASTER can contribute to the computation or not; it is your choice. Each slave simulates the bodies force, only for its bodies, and sends results of its bodies, needed for the next simulation step—the hard part of the problem concerning how to reduce the communication overhead. For the initialization phase, you can consider creating the bodies in a file, and all processors start by reading this file or use a deterministic algorithm to randomize the bodies initialization. The important part is that the execution using one or P processors must generate the same output.

</p>
</details>


### Word Count

<details><summary>Open description ↓</summary>
<p>

<strong>Problem Description</strong>

The word count is the number of words in a document or passage of text. Word counting may be needed when a text is required to stay within specific numbers of words. This may particularly be the case in academia, legal proceedings, journalism, and advertising. Word count is commonly used by translators to determine the price of a translation job. Word counts may also be used to calculate measures of readability and to measure typing and reading speeds (usually in words per minute). When converting character counts to words, a measure of 5 or 6 characters to a word is generally used for English.

<img src="https://raw.githubusercontent.com/spagnuolocarmine/spagnuolocarmine.github.io/master/assets/img/words.gif" alt="wordscount" width="200" style="margin: 10px auto 20px; display: block;" />



We will be doing a version of map-reduce using MPI to perform word counting over a large number of files. 

There are three steps for this process:

1. the MASTER node reads the file list (or a directory), which will contain the names of all the files that are to be counted. Note that only 1 of your processes should read the files list. Then each of the processes should receive their portion of the file from the MASTER process. Once a process has received its list of files to process, it should then read in each of the files and perform a word counting, keeping track of the frequency each word found in the files occurs. We will call the histogram produced the local histogram. This is similar to the map stage or map-reduce.
2. the second phase is combining the frequencies of words across processes. For example, the word 'cat' might be counted in multiple processes, and we need to add up all these occurrences. This is similar to the reduced stage of map-reduce. 
3. the last phase is to have each of the processes send their local histograms to the master process. The MASTER process just needs to gather up all this information. Note that there will be duplicate words between processes. The master should create a CSV formatted file with the words and frequencies ordered.

<strong>Notes</strong>

The hard part of the problem concerns to split equally the computation among the processors. For instance, if we split the files between processors, we cannot have a good partitioning scheme because some files must be bigger and bigger than other files. A good partitioning scheme must consider the number of words in each file, and split according to this value.

</p>
</details>





## Give me a project now!
 
Compute the [MD5](https://www.md5hashgenerator.com/) a string representing your name, surname, and birth date, as follow: 

```javascript
String x = "$NAME$SURNAME$DATE"
xmd5 = md5(x)
```
Your homework matching is computed according the following rules:

- ```xmd5[0]``` the first character in the MD5 is the homework;
- ```xmd5[strlen(xmd5)-1]``` the last character in the MD5 is the AWS EC2 instance type for your cluster environment.

Characters table conversion (use case insentive):

| Project Character - ```xmd5[0]``` |Value|
|---|---|
|a-g-m-s-y-4-b-h-n-t-z-5|1|
|c-i-o-u-0-6-d-j-p-v-1-7|2|
|e-k-q-w-2-8-f-l-r-x-3-9|3|

[↑  List of homeworks ↑ ](#homeworks-list)

| Instance Type Character - ```xmd5[strlen(xmd5)-1]``` |Value|
|---|---|
|a-g-m-s-y-4|1|
|b-h-n-t-z-5|2|
|c-i-o-u-0-6|3|
|d-j-p-v-1-7|4|
|e-k-q-w-2-8|5|
|f-l-r-x-3-9|6|

[↓ List of AWS EC instances ↓](#how-benchmark-your-mpi-program-on-a-aws-ec2-cluster)

**Example** 
My name is Alice Liddell, I am the heroine of the well-known book _Alice's Adventures in Wonderland_ , and I was born someday in 1865, I love to imagine that the day is March, 15.

Homework matching is computed as follow:
```javascript
String x ="aliceliddell01503865" 
md5x = md5(x) //3a57befe3f6415dc13766d3219f63e57
prinln(xmd5[0]) //3
println(xmd5[strlen(xmd5)-1]) //7
```

**Alice's homework matching** is solving the _wordscount_ problem on _t2.2xlarge_ instances.

[↑ Back to Index ↑](#table-of-contents)

# Submit your course homework

## Prepare your submission 

Each solution should be a files repository (or directory), that contains the C sources, the report file (in both Markdown and PDF), and all images (if needed). 

The report file must include a:
- presentation of the proposed solution;
- detailed description of your project structure, and a summary of your code, which highlights the crucial aspect of your solution; 
- deeply analysis of the performance of your program, described in terms of weak and strong scalability;
- conclusion section, where is analyzed the reason for the obtained performance. 

⚠️ Solutions without the report file and/or cannot easily compiled and executed using only mpicc  and mpirun - will be not considered!

**Notes about the creation of a Tape-archive**

For archiving all files in the current directory:
```
tar -cvf solution.tar.gz *
```
For extracting files from a tape-archive:
```
tar -xvf solution.tar.gz
```

### Submission instructions

- Each solution should be compliant with the problem project exam. 
- You can submit a solution via mail 
  - Mail address: cspagnuolo+PCPC-2020-SUBMISSION@unisa.it
  - Subject: Your Name & Surname, Project Title, Official exam date (ESSE3)
  - Body: what you want
  - Attachment:
    -  a compressed directory using tape archive,
    -  a public GitHub repository (⭐️ preferred), 
    -  or any kind of easily accessible method.
- ⚠ <span style="color:red"> The submission deadline is the day of the official exam on the ESSE3 platform.</span>

[↑ Back to Index ↑](#table-of-contents)

# Homework evaluation criteria

Homeworks are evaluated on a range of 30 total points. The final score is expressed in the following four levels:

Level | Range
------- | -------
**A** | [30-28]
**B** | [27-25]
**C** | [24-22]
**D** | [21-18]

## How to have a successful homework evaluation?

- **Correctness**. 0 to 10 points. Measures the student's commitment to developing a solution that is compliant with the problem requirement (obviously!). A solution that partially solves part of the problem will also be considered; if all the crucial aspects of the problems have been faced.

- **Style**. 0 to 10 points. Measures the student's commitment to developing a solution styling it and exploiting all features of MPI and C language, paying attention to use arguments of the parallel and concurrent computing fundamental part.

- **Problem evaluation and Benchmarks**. 0 to 10 points. Measures the student's commitment to understanding the problem and gives the right solution; moreover, it measures the student's commitment to presents a deep analysis of the program performance.


## Benchmarks TIPS 

Present your results in terms of strong and week scalability:

- **Strong Scalability**: How fast the problem size must increase to maintain a fixed efficiency when the number of
processes is increased. In practice, the total problem size stays the same as the number of processors increases.  **Goal**: Minimize time to solution for a given problem.
- **Weak Scalability**: How fast the efficiency decreases when the number of processes increases, but the problem size is fixed. In practice, the problem size increases at the same rate as the number of processors, keeping the amount of work per processor equal. **Goal**: solve the larger problems.


## How benchmark your MPI program on a AWS EC2 cluster? 

<img src="https://raw.githubusercontent.com/spagnuolocarmine/spagnuolocarmine.github.io/master/assets/img/aws.png" alt="aws" width="200" style="margin: 10px auto 20px; display: block;" />

All information about configuring a cluster of Amazon EC2 instances are available on this [repository](https://github.com/spagnuolocarmine/ubuntu-openmpi-openmp).

**Amazon educate program supports only several AWS services**, at this [link](https://s3.amazonaws.com/awseducate-starter-account-services/AWS_Educate_Starter_Accounts_and_AWS_Services.pdf) are described all limitations for educate account.

**Supported Instances<a name="instaces"></a>**

ID | EC2 Instance name
------- | -------
1 | t2.small
2 | t2.large
3 | t2.xlarge
4 | t2.2xlarge
5 | m4.large
6 | m4.xlarge

<!--
### Project Request
<iframe src="https://docs.google.com/forms/d/e/1FAIpQLScw6qbFwtbFc0EaCc4iLRTyo_1H46uWiDc-JMsGI0-3au1u1A/viewform?embedded=true" width="640" height="1239" frameborder="0" marginheight="0" marginwidth="0">Caricamento in corso...</iframe>

-->
[↑ Back to Index ↑](#table-of-contents)

# The last "dance" of your course 

**Homework Discussion**

Finally, when the project is submitted by mail before the official exam date. 

You have to fix an appointment to discuss the project via email:
  - Mail address: cspagnuolo+PCPC-2020-DISCUSSIOn@unisa.it
  - Subject: Your Name & Surname, Project Title, Discussion
  - Body: a list of at least 4 possible days (with the time indication, e.g. 15:00), 
    - ⚠️ notice that all the days must be BEFORE the oral exam.

**What will the discussion be about?**

During the discussion, we will friendly investigate with the proposed solution, following the submitted report file and analyzing the most important part of the code. For discussion will be used the Discord [![Discord](https://img.shields.io/discord/693092516286693387.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/BTt5fUp) platform, in PVT video call. Other instructions will be defined for each appointment.

[↑ Back to Index ↑](#table-of-contents)